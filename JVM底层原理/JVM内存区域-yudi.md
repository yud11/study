

# jvm内存区域

java虚拟机在执行java程序时，会将它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，已经创建时间和销毁时间，具体请看下图

## 程序计数器

程序计数器是指当前线程所执行的**字节码的行号指示器**，即存储的是下一条需要执行的字节码指令。为了在多线程中，线程切换能恢复到正确的执行位置，每个线程都需要一个独立的程序计数器。

若正在执行的是Native方法，则程序计数器的值为空（undefined）。此内存区域是唯一一个在jvm规范中没有规定任何OutOfMemoryError情况的区域。

## 虚拟机栈

Java虚拟机栈是线程私有的。它的生命周期和线程一样。它描述的是**Java方法**执行的内存模型。每个方法在执行的同时都会创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。所以我们可以这么来理解，**一个方法对应着一个虚拟机栈。栈是先进后出的，所以在一个方法入栈执行的过程中，如果要调用另一个方法时，会将另一个方法入栈，并等待这个方法执行完毕，出栈，然后继续执行，执行完毕再出栈。**

局部变量表中存放着八大java基本数据类型，引用类型和retureAddress类型（指向了一条字节码的指令），局部变量表需要的内存空间在编译期已经知道大小，所以在该方法所对应的栈帧中，**需要分配多大的局部变量空间是完全确定的，**在方法运行时不会改变局部变量表的大小。

在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError异常，如果虚拟机栈可以动态扩展（Java虚拟机规范也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，将抛出OutOfMemoryError异常。

## 本地方法栈

本地方法栈中执行的是Native方法。**在HotSpot中，将Java虚拟机栈和本地方法栈合二为一。**

## 堆

Java堆是被所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这里分配内存。也是gc回收的主要区域

## 方法区

方法区是各个线程共享的区域，它用于存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。

jdk1.8之前，方法区的实现是永久代，但是在jdk1.7的时候，已经将字符常量和符号引用从方法区移除。jdk1.8及以后，方法区的实现是元空间（metaspace），jdk1.8继承了1.7的一些改变，符号引用存储在native heap中，字符串常量和静态类型变量存储在普通的堆区中。**元空间使用的物理机的直接内存，上不封顶。**

### 运行时常量池

运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。这部分内容将在类加载之后进入到方法区的运行时常量池中存放。Java语言并不要求常量只有编译器产生，运行期间也可将新的常量放入池中。这种特性被开发人员利用的比较多的就是String类的intern()方法。

### String的intern方法

当调用intern方法时，如果常量池已经包含与方法确定的相当于此`String`对象的字符串，则返回来自常量池的字符串引用。否则，此`String`对象将添加到池中，并返回对此`String`对象的引用。

## 直接内存

在jdk1.4之后新加入了NIO，可以使用native函数库直接分配堆外内存（本机内存），然后通过一个存储在java堆中的directByteBuffer对象作为这块内存的引用进行操作。避免了io在java堆和native堆来回复制数据
# 如何判断对象是否可以回收

## 引用计数法

引用计数法是指给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时候计数器值为0就表示不会再被任何对象使用。客观的说，引用计数法（Reference Counting）的实现简单，判断效率也很高，在大部分情况下都是一个不错的算法。但在主流的Java虚拟机里面没有使用引用计数法来管理内存，主要原因是它很**难解决对象之间相互循环引用的问题。**

## 可达性分析算法

在主流的商用程序语言（Java、C#）的主流实现中，都是通过可达性分析（ReachabilityAnalysis）来判断对象是否存活的。这个算法的基本思路是通过一系列称为GC Roots的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链（就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。

在Java语言中，可作为GC Roots的对象包括下面几种：

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象。

2. 方法区中类静态属性引用的对象。

3. 方法区中常量引用的对象。

4. 本地方法栈中JNI（即Native方法）引用的对象。

**为什么对象的成员变量不能作为GC roots呢？**

因为这个成员变量所在的对象有可能此时没有地方引用，所以这两个对象应该都要在gc时，回收掉内存。

# 对象的回收过程

一个对象死亡，至少要被标记两次。当一个对象被==标记二次==，才会被真正的回收

1）在可达性算法分析中不可达的对象，会被jvm标记

2）判断对象是否要执行finalize方法，当对象没有覆盖finalize()方法或者finalize()方法已经被执行过，jvm进行第二次标记。

**注意**：**任何一个对象的finalize方法只会被调用一次**

## 回收方法区

### 回收方法区的条件

1. 该类所有的实例已经被回收，也就是Java堆中不存在该类的任何实例。
2. 加载该类的ClassLoader已经被回收。
3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机可以对满足上面3个要求的无用类进行回收，这里说的仅仅是可以，而不是像对象一样，不用了就必然会回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证方法区不会溢出。

# 垃圾收集算法

本文主要介绍如下三种常见的jvm的垃圾收集算法

## 标记-清除算法

该算法分为以下两步：

1）标记所有需要回收的对象

2）在标记完成之后，回收被标记的所有对象

**缺点**：

1）效率不高，标记和清除的效率都不高

2）标记清除会产生大量的内存碎片，当内存碎片过多时，可能在分配大对象时，没有空余空间去分配，提前触发垃圾回收

## 复制算法

该算法首先将内存分为两片大小的相等的空间，每次只使用其中的一块，当这块内存使用完，将存活的对象复制到另一块内存中，将原先的那块内存空间一次清理掉。

**优点：**

1）不存在内存碎片问题

2）只要移动堆顶指针，按顺序分配内存，实现简单，运行高效

**缺点：**

1）内存为原来可用空间的一半，代价太大

因为新生代中98%的对象都是朝生夕死的，所以并不需要1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和一块Survivor空间。当回收时，将Eden和Survivor中开存活的对象一次性复制到另一块Survivor空间上，最后清理掉Eden和刚才使用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小是8:1，也就是每次新生代可用空间是整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%可回收只是一般的情况的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。

## 标记-整理算法

该算法和标记-清除算法很相似，步骤如下

1）标记所有需要回收的对象

2）**让所有存活的对象向一端移动**，然后直接清理掉端边界以外的内存。

**优点：**

1）不耗费多余的内存

2）不产生内存碎片

## 分代收集算法

当前商业虚拟机的垃圾收集都采用“分代收集”（GenerationalCollection）算法，这种算法只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆划分为==新生代==和==老年代==，这样就可以根据各个年代的特点采用最适合的收集算法。在新生代中每次都有大量的对象死去，只有少量存活，那就采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它们进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

# 垃圾收集器

目前JVM的垃圾有如下几种

![](images/垃圾收集器与内存分配策略-yudi-1.png)

## Serial收集器

Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK1.3.1之前）是虚拟机新生代收集的唯一选择。根据名字可以知道，这个收集器是**单线程收集器，**但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在完成垃圾收集工作时，必须暂停其他所有的工作线程，直到它收集结束。

## ParNew收集器

ParNew收集器实际上就是Serial收集器的多线程版本，除了Stop  The World的时候，采用多线程回收垃圾，其他的和Serial收集器并没有太大区别。

## Parallel Scavenge收集器

Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目的是达到一个可控制的吞吐量（Throughout）。所谓吞吐量就是CPU运行用户代码的时间与CPU总消耗时间的比，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉了1分钟，那吞吐量就是99%。

停顿时间越短就越适合与用户交互的程序，良好的响应速度能提高用户体验，而高吞吐量则可以高效率的利用CPU时间，尽快的完成程序的计算任务，主要适合在后台运算而不需要太多交互的任务。

Parallel Scavenge收集器有一个参数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开时，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供         最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。如果对收集器运行原理不太了解的话，使用Parallel Scavenge收集器配合自适应管理策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGCMillis参数（更关注最大停顿时间）或GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。

## SerialOld收集器

Serial Old是Serial收集器的老年代版本，它同样是一个==单线程==收集器，使用“==标记-整理==”算法。这个收集器的主要意义也是给Client模式的虚拟机使用。如果在Server模式下，那么它有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案，在并发收集发生Concurrent Mode Failure时使用。

## **ParallelOld收集器**

Parallel Old是Parallel Scavenge收集器的老年代版，使用多线程和“标记-整理”算法。这个收集器是在JDK1.6中才开始提供的，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑ParallelScavenge加Parallel Old收集器。

## **CMS收集器**

CMS（Concurrent Mark Sweep）收集器是一种以**获取最短回收停顿时间**为目标的收集器。目前很大一部分Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其注重服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

从名字（包含“Mark Sweep”）可以看出，CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前几种收集器来说更复杂一些，整个过程分为4个步骤，包括：

1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）
4. 并发清除（CMS concurrentsweep）

其中，初始标记和重新标记仍然需要“StopThe World”。初始标记仅仅是标记一下**GC Roots能直接关联的对象**，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致的标记产生变动的那一部分的标记记录，这个阶段的停顿时间一般会比初始标记的时间稍长一些，但远比并发标记的时间短。

由于整个过程耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

**缺点：**

1. CMS收集器对**CPU资源非常敏感**。其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段。它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量降低。
2. CMS无法处理“**浮动垃圾**”（Floating Garbage），可能出现“ConcurrentMode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分的垃圾就称为“浮动垃圾”。也由于垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器一样等待老年代几乎快被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。
3. CMS是一款基于“**标记-清除”**算法实现的收集器，这意味着收集结束时会有大量的**空间碎片**产生。空间碎片过多时，将会给大对象分配带来很大的麻烦，==往往会出现老年代还有很大的空间剩余，但是无法找到足够的连续空间来分配当前对象，不得不提前触发一次Full GC==。为了解决这个问题，CMS收集器提供了一个-XX+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着进行一次带压缩的（默认值为0，表示每次进行Full GC时都进行碎片整理）。
   

## G1收集器

G1是一款面向服务器的垃圾收集器。HotSpot开发团队赋予它的使命是未来可以替换掉JDK1.5中发布的CMS收集器。与其他收集器相比，G1具备如下特点：

**并行与并发**：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。

**分代收集**：与其他收集器一样，分代的概念在G1中依然保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。

**空间整合**：与CMS的“标记-清理”算法不同，G1从整体来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运行期间不会产生内存碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。

**可预测的停顿**：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

使用G1收集器时，Java堆的内存布局就与其他收集器有很大的差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。

G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个**优先列表**，**每次根据允许的收集时间，优先回收价值最大的Region**（这也就是Garbage-First名称的由来）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

G1收集器的运作大致可划分为如下几个步骤：

1. 初始标记（Initial Marking）
2. 并发标记（Concurrent Marking）
3. 最终标记（Final Marking）
4. 筛选回收（Live Data Countingand Evacuation）
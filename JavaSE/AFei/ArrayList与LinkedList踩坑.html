<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601568 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2755"/>

<div>
<span><div><img src="ArrayList与LinkedList踩坑_files\en_todo.png"/>速读摘要</div><div>其实在大部分情况下这都是没啥问题，无非就是循环的往ArrayList中写入数据而已。比如我们在review代码时发现这里返回的数据有时会高达2000W，这时ArrayList写入的问题就凸显出来了。所以理论上来说它的写入非常高效，将不会有ArrayList中效率极低的数组复制，每次只需要移动指针即可。LinkedList的写入效率高于ArrayList，所以在写大于读的时候非常适用于LinkedList。</div><div><h1>ArrayList 踩坑</h1><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>List&lt;String&gt; temp =new ArrayList();</div><div>//获取一批数据</div><div>List&lt;String&gt; all = getData();</div><div>for(String str : all){</div><div>temp.add(str);</div><div>}</div></div><div>首先大家看看这段代码有什么问题嘛？</div><div>其实在大部分情况下这都是没啥问题，无非就是循环的往 ArrayList 中写入数据而已。</div><div>但在特殊情况下，比如这里的 getData() 返回数据非常巨大时后续 temp.add(str) 就会有问题了。</div><div>比如我们在 review 代码时发现这里返回的数据有时会高达 2000W，这时 ArrayList 写入的问题就凸显出来了。</div><h2>填坑指南</h2><div>大家都知道 ArrayList 是由数组实现，而数据的长度有限；需要在合适的时机对数组扩容。</div><blockquote><div>这里以插入到尾部为例 add(E e)。</div></blockquote><div><img src="ArrayList与LinkedList踩坑_files/640.jpg" type="image/jpeg" data-filename="640.jpg" style="margin:0;padding:0;max-width:100% !important;box-sizing:border-box !important;-webkit-box-sizing:border-box !important;word-wrap:break-word !important;height:auto !important;border-width:2px;border-style:solid;border-color:rgb(238,238,238);border-radius:6px;width:567px !important;__visibility:visible !important"/></div><div>ArrayList temp = new ArrayList&lt;&gt;(2) ;temp.add(&quot;1&quot;);temp.add(&quot;2&quot;);temp.add(&quot;3&quot;);</div><div>当我们初始化一个长度为 2 的 ArrayList ，并往里边写入三条数据时 ArrayList 就得扩容了，也就是将之前的数据复制一份到新的数组长度为 3 的数组中。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private void grow(int minCapacity) {</div><div>   // overflow-conscious code</div><div>   int oldCapacity = elementData.length;</div><div>   int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</div><div>   if (newCapacity - minCapacity &lt; 0)</div><div>       newCapacity = minCapacity;</div><div>   if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</div><div>       newCapacity = hugeCapacity(minCapacity);</div><div>   // minCapacity is usually close to size, so this is a win:</div><div>   elementData = Arrays.copyOf(elementData, newCapacity);</div><div>}</div></div><blockquote><div>之所以是 3 ，是因为新的长度=原有长度 * 1.5</div></blockquote><div>通过源码我们可以得知 ArrayList 的默认长度为 10.</div><div><img src="ArrayList与LinkedList踩坑_files/640 [1].jpg" type="image/jpeg" data-filename="640.jpg" style="margin:0;padding:0;max-width:100% !important;box-sizing:border-box !important;-webkit-box-sizing:border-box !important;word-wrap:break-word !important;height:auto !important;border-width:2px;border-style:solid;border-color:rgb(238,238,238);border-radius:6px;width:677px !important;__visibility:visible !important"/><img src="ArrayList与LinkedList踩坑_files/640 [2].jpg" type="image/jpeg" data-filename="640.jpg" style="margin:0;padding:0;max-width:100% !important;box-sizing:border-box !important;-webkit-box-sizing:border-box !important;word-wrap:break-word !important;background-color:rgb(238,237,235);border-width:2px;border-style:solid;border-color:rgb(238,238,238);background-size:22px;background-position:center center;background-repeat:no-repeat;border-radius:6px;height:81.9925px !important;width:677px !important"/></div><div>但其实并不是在初始化的时候就创建了 DEFAULT_CAPACITY=10 的数组。</div><div><img src="ArrayList与LinkedList踩坑_files/640 [3].jpg" type="image/jpeg" data-filename="640.jpg" style="margin:0;padding:0;max-width:100% !important;box-sizing:border-box !important;-webkit-box-sizing:border-box !important;word-wrap:break-word !important;background-color:rgb(238,237,235);border-width:2px;border-style:solid;border-color:rgb(238,238,238);background-size:22px;background-position:center center;background-repeat:no-repeat;border-radius:6px;height:181.501px !important;width:677px !important"/></div><div>而是在往里边 add 第一个数据的时候会扩容到 10.</div><div>既然知道了默认的长度为 10 ，那说明后续一旦写入到第九个元素的时候就会扩容为 10*1.5=15。这一步为数组复制，也就是要重新开辟一块新的内存空间存放这 15 个数组。</div><div>一旦我们频繁且数量巨大的进行写入时就会导致许多的数组复制，这个效率是极低的。</div><div>但如果我们提前预知了可能会写入多少条数据时就可以提前避免这个问题。</div><div>比如我们往里边写入 1000W 条数据，在初始化的时候就给定数组长度与用默认 10 的长度之间性能是差距巨大的。</div><blockquote><div>我用 JMH 基准测试验证如下：</div></blockquote><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@Warmup(iterations =5, time =1, timeUnit =TimeUnit.SECONDS)</div><div>@Measurement(iterations =5, time =1, timeUnit =TimeUnit.SECONDS)</div><div>publicclassCollectionsTest{</div><div>  privatestaticfinalint TEN_MILLION =10000000;</div><div>  @Benchmark</div><div>  @BenchmarkMode(Mode.AverageTime)</div><div>  @OutputTimeUnit(TimeUnit.MICROSECONDS)</div><div>  publicvoid arrayList(){</div><div>     List&lt;String&gt; array =newArrayList&lt;&gt;();</div><div>     for(int i =0; i &lt; TEN_MILLION; i++){</div><div>        array.add(&quot;123&quot;);</div><div>     }</div><div>  }</div><div>  @Benchmark</div><div>  @BenchmarkMode(Mode.AverageTime)</div><div>  @OutputTimeUnit(TimeUnit.MICROSECONDS)</div><div>  publicvoid arrayListSize(){</div><div>     List&lt;String&gt; array =newArrayList&lt;&gt;(TEN_MILLION);</div><div>     for(int i =0; i &lt; TEN_MILLION; i++){</div><div>        array.add(&quot;123&quot;);</div><div>     }</div><div>  }</div><div><br/></div><div><br/></div><div>  publicstaticvoid main(String[] args)throwsRunnerException{</div><div>     Options opt =newOptionsBuilder()</div><div>           .include(CollectionsTest.class.getSimpleName())</div><div>           .forks(1)</div><div>           .build();</div><div>     newRunner(opt).run();</div><div>  }</div><div>}</div></div><div><img src="ArrayList与LinkedList踩坑_files/640 [4].jpg" type="image/jpeg" data-filename="640.jpg" style="margin:0;padding:0;max-width:100% !important;box-sizing:border-box !important;-webkit-box-sizing:border-box !important;word-wrap:break-word !important;height:auto !important;border-width:2px;border-style:solid;border-color:rgb(238,238,238);border-radius:6px;width:642px !important;__visibility:visible !important"/></div><div>根据结果可以看出预设长度的效率会比用默认的效率高上很多（这里的 Score 指执行完函数所消耗的时间）。</div><div>所以这里强烈建议大家：在有大量数据写入 ArrayList 时，一定要初始化指定长度。</div><hr style="background-color: rgb(255, 255, 255); margin: 1.5rem 0px; padding: 0px; letter-spacing: 0.544px; white-space: normal; border-style: dashed none none; border-top-color: rgb(165, 165, 165); border-right-width: initial; border-right-color: initial; border-left-width: initial; border-left-color: initial; border-bottom-width: initial; border-bottom-color: initial; height: 1px; color: rgb(80, 97, 109); text-align: start; max-width: 100% !important; box-sizing: border-box !important; word-wrap: break-word !important;"/><div>再一个是一定要慎用 add(int index,E element) 向指定位置写入数据。</div><div><img src="ArrayList与LinkedList踩坑_files/640 [5].jpg" type="image/jpeg" data-filename="640.jpg" style="margin:0;padding:0;box-sizing:border-box !important;-webkit-box-sizing:border-box !important;word-wrap:break-word !important;__visibility:visible !important;width:auto !important;max-width:100% !important;height:auto !important"/></div><div>通过源码我们可以看出，每一次写入都会将 index 后的数据往后移动一遍，其实本质也是要复制数组；</div><div>但区别于往常规的往数组尾部写入数据，它每次都会进行数组复制，效率极低。</div><h1>LinkedList</h1><div>提到 ArrayList 就不得不聊下 LinkedList 这个孪生兄弟；虽说都是 List 的容器，但本质实现却完全不同。</div><div><img src="ArrayList与LinkedList踩坑_files/640 [6].jpg" type="image/jpeg" data-filename="640.jpg" style="margin:0;padding:0;box-sizing:border-box !important;-webkit-box-sizing:border-box !important;word-wrap:break-word !important;__visibility:visible !important;width:auto !important;max-width:100% !important;height:auto !important"/></div><div>LinkedList 是由链表组成，每个节点又有头尾两个节点分别引用了前后两个节点；因此它也是一个双向链表。</div><div>所以理论上来说它的写入非常高效，将不会有 ArrayList 中效率极低的数组复制，每次只需要移动指针即可。</div><h1>对比测试</h1><div>坊间一直流传：</div><blockquote><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">LinkedList 的写入效率高于 ArrayList，所以在写大于读的时候非常适用于 LinkedList 。</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><br/></span></div></blockquote><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@Benchmark</div><div>@BenchmarkMode(Mode.AverageTime)</div><div>@OutputTimeUnit(TimeUnit.MICROSECONDS)</div><div>publicvoid linkedList(){</div><div>List&lt;String&gt; array =newLinkedList&lt;&gt;();</div><div>for(int i =0; i &lt; TEN_MILLION; i++){</div><div>array.add(&quot;123&quot;);</div><div>}</div><div>}</div></div><div><br/></div><div><img src="ArrayList与LinkedList踩坑_files/640 [7].jpg" type="image/jpeg" data-filename="640.jpg" style="padding: 0px; border-width: 2px; border-style: solid; border-color: rgb(238, 238, 238); border-radius: 6px; box-sizing: border-box !important; word-wrap: break-word !important; width: 558px !important;"/></div><div><br/></div><div>这里测试看下结论是否符合；同样的也是对 LinkedList 写入 1000W 次数据，通过结果来看<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">初始化数组长度的 ArrayList 效率明显是要高于 LinkedList</span> 。</div><div>但这里的前提是要<span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">提前预设 ArrayList 的数组长度，避免数组扩容，这样 ArrayList 的写入效率是非常高的，而 LinkedList 的虽然不需要复制内存，但却需要创建对象，变换指针等操作</span>。</div><div>而查询就不用多说了， ArrayList 可以支持下标随机访问，效率非常高。</div><div>LinkedList 由于底层不是数组，不支持通过下标访问，而是需要根据查询 index 所在的位置来判断是从头还是从尾进行遍历。</div><div><img src="ArrayList与LinkedList踩坑_files/640 [8].jpg" type="image/jpeg" data-filename="640.jpg" style="margin:0;padding:0;max-width:100% !important;box-sizing:border-box !important;-webkit-box-sizing:border-box !important;word-wrap:break-word !important;height:auto !important;border-width:2px;border-style:solid;border-color:rgb(238,238,238);border-radius:6px;width:677px !important;__visibility:visible !important"/></div><div>但不管是哪种都得需要移动指针来一个个遍历，特别是 index 靠近中间位置时将会非常慢。</div><h1>总结</h1><div>高性能应用都是从小细节一点点堆砌起来的，就如这里提到的 ArrayList 的坑一样，日常使用没啥大问题，一旦数据量起来所有的小问题都会成为大问题。</div><div>所以再总结下：</div><ol><li><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">再使用 ArrayList 时如果能提前预测到数据量大小，比较大时一定要指定其长度。</span></div></li><li><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">尽可能避免使用 add(index,e) api，会导致复制数组，降低效率。</span></div></li><li><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">再额外提一点，我们常用的另一个 Map 容器 HashMap 也是推荐要初始化长度从而避免扩容。</span></div></li></ol><div>本文所有测试代码：</div><div>https://github.com/crossoverJie/JCSprout/blob/master/src/main/java/com/crossoverjie/basic/CollectionsTest.java</div></div><div><br/></div></span>
</div></body></html> 
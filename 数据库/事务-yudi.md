# 前言

事务是数据库区别于文件系统的重要特性之一。它会把数据库从一种一致状态转换为另一种一致状态。

# 事务特性

## 原子性（atomicity）

整个数据库事务是不可分割的工作单位。只有使事务中所有的数据库操作都执行成功，才算整个事务成功。事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。

## 一致性（consistency）

一致性指事务将数据库从一种状态转变为下一种一致性状态。在事务开始之和事务结束以后，数据库的完整性约束没有被破坏。

## 隔离性（isolation）

事务的隔离性要求每个读写事务的对象对其他事务的操作能相互分离，即该事务提交前对其他事务都不可见。使用锁来实现

## 持久性（durability）

事务一旦提交，其结果是永久性的。即使数据库发生宕机等故障，数据库也能将数据恢复。使用redo日志来保证。但是若操作系统发生故障，raid卡损坏，这种原因，所有提交的数据可能都会丢失。一致性保证了系统的高可靠性，而不是高用性。高可用性需要用集群来实现。

# 事务实现

事务隔离性由锁，mvcc来实现。而原子性，一致性，持久性通过数据库的redo log，undo log来完成。redo是物理日志，记录的是页的物理修改操作。undo是逻辑日志，根据每行记录进行记录。

## redo日志

redo日志用来恢复提交事务修改的页操作。当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化。为了确保每次日志都写入重做日志文件，在每次将重做日志缓冲写入重做日志文件后，Innodb都需要调用一次fsync操作，如果不使用fsync，只能保证日志已经写入操作系统的缓存中，并没有写入磁盘。这时若操作系统发生宕机，则数据会丢失。参数innodb_flush_log_at_trx_commit可以用来控制重做日志刷新到磁盘的策略。

### 二进制日志和redo日志的区别

二进制日志用来进行POINT-IN-TIME的恢复以及主从复制环境的建立。它和redo日志很相似，都是记录了对数据库的操作，然而从本质上来说，两者有很大的不同。
1）重做日志是在Innodb存储引擎层产生的，二进制日志是在mysql数据库上层产生的，任何存储引擎都会产生binlog

2）binlog是一种逻辑日志，其记录的是对应的SQL语句。而redo log 是物理格式日志，其记录的是对于每个页的修改

3）binlog只在事务提交完成后进行一次写入。而redolog在事务进行中不断被写入，这表现为日志不是随着事务提交的顺序进行写入的。

### log block

在innodb存储引擎中，redolog是以块（block）的形式存在的，每个块大小为512字节。由于重做日志块的大小和磁盘扇区大小一样，都是512字节，因此重做日志ed写入可以保证原子性，不需要doublewrite技术。

## undo日志

### 基本概念

undo日志，记录了事务开始之前的状态，当用户执行的事务或语句由于某种原因失败了，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。

undo存在数据库内部的一个特殊段中，这个段称为undo段。

**undo是逻辑日志。**因为只能将数据库逻辑地恢复到原来的样子。所有的修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。这是因为在多用户并发系统中，可能有数千个并发事务。若将一个页回滚到事务开始的样子，这样会影响其他事务正在进行的工作。

undo可以用来实现mvcc，当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读取。

undo会产生redolog，这是因为undolog也需要持久化的保护。

### undo存储管理

当事务提交时，Innodb存储引擎会做以下两件事情：

​	1）将undolog 放入列表中，以供之后的purge操作

​    2）判断undo log所在的页是否可以重用，若可以分配给下个事务使用

事务提交之后并不能马上删除undolog 和undolog所在的页，这是因为可能还有其他事务需要通过undolog来得到行记录之前的版本。故事务提交时将undolog放入一个链表中，是否可以删除由purge线程来判断。

# 事务隔离级别

SQL标准定义的四个隔离级别

- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE

Innodb存储引擎默认支持的隔离级别是REPEATABLE READ,而在REPEATABLE READ级别下回产生幻读现象，而innodb存储引擎使用next-key算法保证了不会出现幻读现象，从而达到了串行化隔离级别才能达到的效果。


## AOF

### 简介

当打开AOF的功能时，Redis服务端会将每次对数据库的写命令以文件协议的方式保存到AOF文件中。

### 追加过程

​	当客户端发送一条写命令到服务端后，服务端执行完成后，判断aof程序是否已经打开，若打开了aof程序，命令参数都会被传给aof程序，此时aof程序拿到命令的一些参数后会将命令的协议内容追加到服务器状态的**aof_buf缓冲区**，当服务端每次结束事件循环之前会调用**flushAppendOnlyFile**函数，考虑是否需要将aof_buf缓冲区中的内容写入和保存到aof文件中。这个考虑是基于服务器配置的appendfsync选项值（**always、everysec、no**）来决定。

![1628062871197](C:/Users/zxw/AppData/Roaming/Typora/typora-user-images/1628062871197.png)

### 载入与数据还原过程

​	当服务器启动aof载入程序时，会创建一个不带网络连接的伪客户端，然后从aof文件中分析并读取一条写命令，使用伪客户端执行写命令，一直反复，直到aof文件中所有写命令被执行完为止。

![1628063735728](C:/Users/zxw/AppData/Roaming/Typora/typora-user-images/1628063735728.png)

### 思考

​	如果某个系统很大，数据量很多，那么就会产生一个问题：随着时间的推移，aof文件的体积会越来越大，如果不加以控制，这个文件可能会对Redis服务器造成影响，并且如果aof文件体积越来越大，那么还原数据所需要的时间会越来越多。

​	基于上面的问题，Redis给出了Aof重写的机制，来解决这个问题。当Aof文件达到了一定的阈值，会进行aof文件重写达到缩小aof文件的目的。

### Aof重写

#### 简介

​	aof重写并不需要通过对现有的aof文件进行读取、写入和分析操作，而是通过读取当前数据库状态来实现的。

#### 触发条件

- 手动执行 bgrewriteaof 触发AOF重写
- 在redis.conf文件中配置重写的条件，如：
  ![1628065482571](C:/Users/zxw/AppData/Roaming/Typora/typora-user-images/1628065482571.png)

#### 重写过程

![1628067910291](C:/Users/zxw/AppData/Roaming/Typora/typora-user-images/1628067910291.png)

​	主进程fork一条子进程，子进程进行aof重写期间，主进程可以继续处理请求，子进程带有主进程的数据副本，子进程通过读取数据库状态中的数据将写命令追加到新aof文件中。

​	但是上述过程中会出现一个问题：因为子进程在进行aof重写期间，主进程可以处理客户端发来的请求，包括写操作，这个写操作对数据库状态进行了修改，从而使得主进程中的数据库状态与重写后的aof文件所保存的数据库状态不一致。

​	为了解决这个问题，Redis服务器设置了一个**aof重写缓冲区**，这个缓冲区会在服务器fork子进程之后开始使用，当Redis执行完一个写命令后，它会将这个写命令同时发送给aof缓冲区和aof重写缓冲区。所以在子进程进行aof重写过程时，主进程会进行以下三个动作：

- 执行这条写命令
- 将这条写命令发送给aof缓冲区，用以后续正常的aof文件写入和保存
- 将这条写命令发送给aof重写缓冲区。

​	这样就保证了：

- aof缓冲区的内容会定期被写入和同步到aof文件中，对现有的aof文件的处理工作没有影响
- 从创建子进程开始，服务器执行的所有写命令都会被记录到aof重写缓冲区里

​    当子进程完成aof重写之后，会向主进程发送一个信号，主进程接受到这个信号后会调用一个**信号处理函数**，这个函数会执行以下工作：

- 将所有aof重写缓冲区中的内容写入到新aof文件中，这样新的aof文件中数据库状态和服务器的数据库状态一致
- 对新的aof文件进行改名，原子性的覆盖现有的aof文件，完成新旧两个aof文件的替换

